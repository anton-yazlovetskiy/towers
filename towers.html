<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Breach & Stronghold: Tactics</title>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            /* --- ARMY COLORS (High Contrast) --- */
            --p1: #ecf0f1; --p1-t: #2c3e50; --p1-b: #bdc3c7; /* White/Steel */
            --p2: #e74c3c; --p2-t: #fff;    --p2-b: #c0392b; /* Red */
            --p3: #2ecc71; --p3-t: #fff;    --p3-b: #27ae60; /* Emerald */
            --p4: #f39c12; --p4-t: #fff;    --p4-b: #d35400; /* Orange/Gold */
            
            /* --- BASE VARIABLES --- */
            --accent: #e67e22; /* Orange for text visibility */
            --danger: #e74c3c; 
            --success: #27ae60;
            --special: #9b59b6;
            --radius: 8px;
        }

        /* --- DARK MODE (Default) --- */
        body {
            --bg: #121212; 
            --panel: #1e1e1e; 
            --text: #e0e0e0;
            --wrapper-bg: #000000;
            --board-bg: #181818;
            --cell-1: #2c2c2c; --cell-2: #3a3a3a;
            --shadow: 0 4px 12px rgba(0,0,0,0.5);
            --font: 'Segoe UI', sans-serif;
        }

        /* --- LIGHT MODE --- */
        body.mode-light {
            --bg: #f0f2f5;
            --panel: #ffffff;
            --text: #2c3e50;
            --wrapper-bg: #dfe6e9;
            --board-bg: #bdc3c7;
            --cell-1: #ecf0f1; --cell-2: #bdc3c7;
            --shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        /* --- THEME: FUTURE (Optional toggle) --- */
        body.theme-future {
            --font: 'Orbitron', sans-serif;
            --accent: #00e5ff;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
        body { margin: 0; background: var(--bg); color: var(--text); font-family: var(--font); height: 100vh; overflow: hidden; display: flex; flex-direction: column; transition: background 0.3s, color 0.3s; }

        /* --- NOTIFICATIONS --- */
        #notifications {
            position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
            z-index: 3000; display: flex; flex-direction: column; gap: 8px; pointer-events: none; width: 90%; max-width: 400px;
        }
        .toast {
            background: var(--panel); color: var(--text); padding: 12px 20px;
            border-radius: var(--radius); box-shadow: var(--shadow);
            border-left: 5px solid var(--accent); font-weight: bold; border: 1px solid rgba(128,128,128,0.2);
            animation: toast-in 0.2s ease-out forwards; opacity: 0;
        }
        @keyframes toast-in { from { opacity: 0; transform: translateY(-15px); } to { opacity: 1; transform: translateY(0); } }

        /* --- LAYOUT --- */
        #game-layout {
            display: grid;
            grid-template-columns: 320px 1fr 320px;
            grid-template-rows: 60px 1fr 80px;
            width: 100%; height: 100%;
        }

        /* HEADER */
        .top-bar { grid-column: 1 / -1; background: var(--panel); display: flex; align-items: center; justify-content: space-between; padding: 0 20px; border-bottom: 2px solid rgba(128,128,128,0.1); z-index: 100; }
        .badge { font-weight: 800; padding: 6px 16px; border-radius: 20px; font-size: 1.1rem; display: flex; align-items: center; gap: 8px; border: 2px solid transparent; background: rgba(128,128,128,0.1);}
        
        .header-btn {
            background: rgba(128,128,128,0.1); color: var(--text); border: none; width: 40px; height: 40px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center; cursor: pointer; transition: 0.2s;
        }
        .header-btn:hover { background: var(--danger); color: white; transform: rotate(90deg); }

        /* SIDEBARS */
        .card-panel { background: var(--panel); padding: 0; overflow-y: hidden; border-right: 2px solid rgba(128,128,128,0.1); border-left: 2px solid rgba(128,128,128,0.1); display: flex; flex-direction: column; }
        .rules-content { padding: 15px; overflow-y: auto; flex-grow: 1; display: flex; flex-direction: column; gap: 15px; scrollbar-width: thin; }
        
        /* SETTINGS AREA (Bottom Left) */
        .settings-dock {
            padding: 15px; border-top: 1px solid rgba(128,128,128,0.2);
            display: flex; justify-content: space-around; background: rgba(0,0,0,0.05);
        }
        
        .rule-card { background: rgba(128,128,128,0.08); border-radius: var(--radius); overflow: hidden; border: 1px solid rgba(128,128,128,0.1); }
        .card-header { background: rgba(128,128,128,0.1); padding: 8px 12px; font-weight: 700; color: var(--accent); font-size: 0.85rem; letter-spacing: 1px; text-transform: uppercase; display: flex; align-items: center; }
        .card-body { padding: 10px 12px; font-size: 0.85rem; line-height: 1.4; opacity: 0.9; }
        .hl { color: var(--accent); font-weight: 700; text-decoration: underline; text-decoration-color: var(--accent); }

        /* --- BOARD --- */
        .board-wrapper { 
            grid-column: 2; grid-row: 2; 
            display: flex; justify-content: center; align-items: center; 
            background: var(--wrapper-bg); 
            position: relative; overflow: hidden; transition: background 0.3s;
        }
        .board { 
            display: grid; 
            width: min(92vmin, 620px); height: min(92vmin, 620px); 
            background: var(--board-bg); padding: 5px; border-radius: var(--radius);
            box-shadow: 0 0 40px rgba(0,0,0,0.3); position: relative; transition: 0.3s;
        }
        .cell { position: relative; border-radius: 2px; transition: background 0.2s; }
        .cell.c1 { background: var(--cell-1); } .cell.c2 { background: var(--cell-2); }
        .cell.setup-valid { box-shadow: inset 0 0 0 2px var(--success); background: rgba(39, 174, 96, 0.2); }
        .cell.selected { background: rgba(255, 255, 255, 0.3) !important; }

        /* Refresh Button */
        .refresh-btn {
            position: absolute; bottom: 10px; right: 10px;
            background: rgba(128,128,128,0.5); color: #fff; border: none;
            width: 32px; height: 32px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.2s;
        }
        .refresh-btn:hover { background: var(--accent); color: #000; transform: rotate(180deg); }

        /* --- INDICATORS --- */
        .indicator {
            position: absolute; inset: 20%; border-radius: 50%; opacity: 0.8; z-index: 25; pointer-events: none;
            animation: pulse 1.5s infinite;
        }
        .indicator.ind-move { background: var(--success); opacity: 0.3; }
        .indicator.ind-attack { inset: 0; background: transparent; border: 4px solid var(--danger); animation: pulse-fast 0.5s infinite; }
        .indicator.ind-special { inset: 10%; background: transparent; border: 2px dashed var(--special); }

        /* --- PIECES --- */
        .piece {
            width: 80%; height: 80%; position: absolute; top: 10%; left: 10%;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Material Icons'; font-size: clamp(16px, 4vmin, 32px);
            border-radius: 50%; cursor: pointer; z-index: 10;
            transition: transform 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            box-shadow: 0 4px 6px rgba(0,0,0,0.4);
            border-width: 5px; border-style: solid;
        }
        .piece.active-glow { z-index: 20; animation: bounce 1s infinite; border-width: 3px !important; box-shadow: 0 0 15px var(--accent); }
        
        @keyframes bounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.15); } }
        
        .ghost {
            opacity: 1; z-index: 15; pointer-events: none; filter: grayscale(1);
            animation: ghostAnim 0.6s forwards ease-out;
        }
        @keyframes ghostAnim { 0% { transform: scale(1); opacity: 0.8; background: var(--danger); } 100% { transform: scale(1.5); opacity: 0; filter: blur(4px); } }

        /* Shapes & Colors */
        .type-P::before { content: 'circle'; font-size: 0.8em; }
        .type-V { border-radius: 15%; } .type-V::before { content: 'star'; font-size: 1.1em; }
        .type-T { border-radius: 4px; } .type-T::before { content: 'fort'; }
        
        /* Updated Army Colors */
        .p1 { background: var(--p1-t); color: var(--p1); border-color: var(--p1); }
        .p2 { background: var(--p2); color: var(--p2-t); border-color: var(--p2-b); }
        .p3 { background: var(--p3); color: var(--p3-t); border-color: var(--p3-b); }
        .p4 { background: var(--p4); color: var(--p4-t); border-color: var(--p4-b); }

        /* --- CONTROLS --- */
        .controls-area { grid-column: 2; grid-row: 3; display: flex; justify-content: center; align-items: center; gap: 20px; background: var(--panel); border-top: 2px solid rgba(128,128,128,0.1); }
        button {
            border: none; padding: 12px 24px; border-radius: var(--radius);
            font-weight: bold; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; font-family: var(--font);
            color: white; background: rgba(128,128,128,0.2); transition: 0.2s; display: flex; align-items: center; gap: 8px; font-size: 0.9rem;
            color: var(--text);
        }
        button:hover { filter: brightness(1.2); transform: translateY(-2px); }
        button:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
        .btn-green { background: var(--success); color: #fff; }
        .btn-red { background: var(--danger); color: #fff; }
        .btn-purple { background: var(--special); color: #fff; }
        .btn-blue { background: #2980b9; color: #fff; }
        .btn-icon-only { padding: 10px; width: 44px; justify-content: center; background: rgba(128,128,128,0.15); }

        /* --- MODAL & FORM --- */
        #modal, #modal-win { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 2000; display: flex; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-box { background: var(--panel); padding: 35px; border-radius: var(--radius); width: 340px; text-align: center; border: 1px solid rgba(128,128,128,0.2); box-shadow: 0 10px 40px rgba(0,0,0,0.5); }
        
        select {
            appearance: none; -webkit-appearance: none;
            width: 100%; padding: 18px; margin: 10px 0 25px 0;
            background: rgba(128,128,128,0.1); color: var(--text);
            border: 1px solid rgba(128,128,128,0.3); border-radius: 8px;
            font-family: var(--font); font-size: 1.1rem; cursor: pointer;
            background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23888' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
            background-repeat: no-repeat; background-position: right 1rem center; background-size: 1.2em;
        }
        
        .check-label {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; padding: 15px; margin: 10px 0 20px 0;
            cursor: pointer; user-select: none; background: rgba(128,128,128,0.05); border-radius: 8px;
        }
        .check-label input { width: 24px; height: 24px; cursor: pointer; }

        .win-title { font-size: 2rem; color: var(--accent); margin-bottom: 20px; font-weight: 800; }

        /* --- FOOTER / COPYRIGHT --- */
        #copyright {
            position: absolute; bottom: 10px; right: 15px;
            display: flex; align-items: center; gap: 8px;
            color: #888; font-size: 0.7rem; z-index: 100;
        }
        #copyright span:hover { color: #ccc; cursor: help; }
        .tooltip {
            position: absolute; bottom: 25px; right: 0;
            background: var(--panel); color: var(--text); padding: 10px; width: 250px;
            border-radius: 4px; font-size: 0.75rem; display: none; text-align: left;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5); pointer-events: none; border: 1px solid rgba(128,128,128,0.2);
        }
        #copyright span:hover + .tooltip { display: block; }
        .mail-link { color: #888; text-decoration: none; transition: 0.2s; }
        .mail-link:hover { color: var(--accent); transform: scale(1.2); }

        @keyframes pulse { 0%, 100% { transform: scale(0.8); opacity: 0.5; } 50% { transform: scale(1); opacity: 0.8; } }
        @keyframes pulse-fast { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        @media (max-width: 900px) {
            #game-layout { grid-template-columns: 1fr; grid-template-rows: 60px 1fr auto auto; overflow-y: auto; display: flex; flex-direction: column; }
            .card-panel { display: none; }
            .board-wrapper { flex-grow: 1; padding: 15px 0; min-height: 50vh; }
            .controls-area { padding: 15px; min-height: 80px; }
            #copyright { position: relative; bottom: auto; right: auto; justify-content: center; margin-bottom: 10px; }
        }
    </style>
</head>
<body class="mode-dark">

<div id="notifications"></div>

<div id="modal">
    <div class="modal-box">
        <h2 style="color:var(--accent); margin-top:0">НАСТРОЙКИ</h2>
        
        <select id="s-players">
            <option value="2">2 Игрока (Дуэль)</option>
            <option value="3">3 Игрока (FFA)</option>
            <option value="4">4 Игрока (Chaos)</option>
        </select>
        
        <select id="s-size">
            <option value="8">Поле 8 x 8</option>
            <option value="10" selected>Поле 10 x 10</option>
            <option value="12">Поле 12 x 12</option>
        </select>
        
        <label class="check-label">
            <span style="font-weight:bold; color:var(--text)">Агрессивный режим</span>
            <input type="checkbox" id="s-aggro">
        </label>
        
        <button class="btn-green" style="width:100%; justify-content:center; padding:18px; font-size:1.1rem" onclick="Game.start()">В БОЙ</button>
    </div>
</div>

<div id="modal-win" style="display:none">
    <div class="modal-box">
        <div id="win-title" class="win-title">ПОБЕДА!</div>
        <p id="win-desc" style="color:var(--text); margin-bottom:30px; opacity:0.8">Игрок 1 доминирует</p>
        <button class="btn-purple" style="width:100%; justify-content:center" onclick="location.reload()">ГЛАВНОЕ МЕНЮ</button>
    </div>
</div>

<div id="game-layout" style="display:none">
    <div class="top-bar">
        <div id="badge" class="badge p1">Игрок 1</div>
        <div style="font-weight:700; font-size:0.9rem; opacity:0.7" id="phase-msg">ПОДГОТОВКА</div>
        
        <div style="display:flex; align-items:center; gap:15px">
             <div style="font-family:monospace; font-size:1.1em; opacity:0.8">ХОД: <span id="turn-cnt">1</span></div>
             <button class="header-btn" onclick="location.reload()" title="Выход">
                 <span class="material-icons">close</span>
             </button>
        </div>
    </div>

    <div class="card-panel">
        <div class="rules-content">
            <div style="opacity:0.6; font-size:0.7rem; text-align:center; padding-bottom:5px; border-bottom:1px solid rgba(128,128,128,0.2)">
                ЦЕЛЬ: УНИЧТОЖИТЬ БАШНИ ВРАГОВ
            </div>
            <div class="rule-card">
                <div class="card-header"><span class="material-icons" style="font-size:1rem; margin-right:5px">circle</span> РЯДОВОЙ (P)</div>
                <div class="card-body">
                    <p>Ходит на 1. Бьет рядовых.</p>
                    <p><span class="hl">Цепной прыжок:</span> Прыгает через свои фигуры.</p>
                    <p><span class="hl">Слияние:</span> Если нет офицеров, 2 рядовых = Офицер.</p>
                </div>
            </div>
            <div class="rule-card">
                <div class="card-header"><span class="material-icons" style="font-size:1rem; margin-right:5px">star</span> ОФИЦЕР (V)</div>
                <div class="card-body">
                    <p>Ходит на 2. Убивает всех.</p>
                    <p><span class="hl">Слияние:</span> 2 Офицера = Башня (макс 2).</p>
                </div>
            </div>
            <div class="rule-card">
                <div class="card-header"><span class="material-icons" style="font-size:1rem; margin-right:5px">fort</span> БАШНЯ (T)</div>
                <div class="card-body">
                    <p>Потеря всех башен = крах.</p>
                    <p>Двигается, жертвуя союзником.</p>
                </div>
            </div>
        </div>
        
        <div class="settings-dock">
            <button class="btn-icon-only" onclick="Game.toggleAudio()" title="Звук Вкл/Выкл">
                <span class="material-icons" id="icon-sound">volume_up</span>
            </button>
            <button class="btn-icon-only" onclick="Game.toggleMode()" title="День / Ночь">
                <span class="material-icons">brightness_6</span>
            </button>
             <button class="btn-icon-only" onclick="Game.toggleTheme()" title="Стиль: Стандарт / Киберпанк">
                <span class="material-icons">palette</span>
            </button>
        </div>
    </div>

    <div class="board-wrapper">
        <div id="board" class="board"></div>
        <button class="refresh-btn" onclick="View.renderGrid(); View.renderPieces()" title="Перерисовать">
            <span class="material-icons" style="font-size:18px">refresh</span>
        </button>
    </div>

    <div class="card-panel">
        <div class="rules-content">
            <div class="rule-card" style="border-color: var(--danger)">
                <div class="card-header" style="color:var(--danger)">КЛЕЩИ</div>
                <div class="card-body">
                    <p>2 рядовых окружают Офицера -> Офицер мертв, рядовые сливаются.</p>
                </div>
            </div>
            <div class="rule-card" style="border-color: var(--accent)">
                <div class="card-header" style="color:var(--accent)">ПОДДЕРЖКА</div>
                <div class="card-body">
                    <p>Рядовой убивает Офицера, если рядом стоит ваш Офицер.</p>
                </div>
            </div>
            <div class="rule-card" style="border-color: var(--special)">
                <div class="card-header" style="color:var(--special)">ПОНИЖЕНИЕ</div>
                <div class="card-body">
                    <p>Офицера можно разобрать на 2 рядовых.</p>
                </div>
            </div>
            <div style="font-size:0.7rem; opacity:0.5; text-align:center; margin-top:auto">
                3 ПАСА = ПОРАЖЕНИЕ
            </div>
        </div>
    </div>

    <div id="controls" class="controls-area"></div>
</div>

<div id="copyright">
    <span>© 2025 CC BY-NC 4.0</span>
    <div class="tooltip">
        Эта работа лицензирована по CC BY-NC 4.0. Разрешено копирование и адаптация для некоммерческих целей. Коммерческое использование требует разрешения автора.
    </div>
    <a href="mailto:anton.yazlovetskiy@gmail.com" class="mail-link" title="anton.yazlovetskiy@gmail.com">
        <span class="material-icons" style="font-size:16px">mail</span>
    </a>
</div>

<script>
/* --- AUDIO ENGINE --- */
const AudioEngine = {
    ctx: null,
    muted: false,
    
    init() { if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)(); },
    
    createNoiseBuffer() {
        if (!this.ctx) return null;
        const bufferSize = this.ctx.sampleRate * 2.0; 
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        return buffer;
    },

    play(type) {
        if (this.muted) return;
        if (!this.ctx) this.init();
        if (this.ctx.state === 'suspended') this.ctx.resume();
        if (!this.noiseBuffer) this.noiseBuffer = this.createNoiseBuffer();
        
        const t = this.ctx.currentTime;

        if (type === 'move') {
            // Short dry click (Percussive, no sci-fi tail)
            const osc = this.ctx.createOscillator();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, t);
            osc.frequency.exponentialRampToValueAtTime(50, t + 0.05); // Very fast decay
            
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0.5, t);
            g.gain.exponentialRampToValueAtTime(0.01, t + 0.05);
            
            osc.connect(g); g.connect(this.ctx.destination);
            osc.start(t); osc.stop(t + 0.06);
        } 
        else if (type === 'attack') {
            // Crumble sound
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(600, t);
            filter.frequency.linearRampToValueAtTime(100, t + 0.2);
            const gain = this.ctx.createGain();
            gain.gain.setValueAtTime(0.6, t);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
            noise.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
            noise.start(t); noise.stop(t + 0.25);
        }
        else if (type === 'special') {
            const osc = this.ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.setValueAtTime(400, t);
            osc.frequency.linearRampToValueAtTime(800, t + 0.1);
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0.1, t);
            g.gain.linearRampToValueAtTime(0, t + 0.15);
            osc.connect(g); g.connect(this.ctx.destination);
            osc.start(t); osc.stop(t + 0.15);
        }
    }
};

/* --- CORE LOGIC --- */
const Utils = {
    uid: 0,
    getUid: () => `uid-${++Utils.uid}`,
    idx: (r, c, size) => (r >= 0 && r < size && c >= 0 && c < size) ? r * size + c : -1,
    coords: (i, size) => ({ r: Math.floor(i / size), c: i % size }),
    wait: (ms) => new Promise(r => setTimeout(r, ms)),
    deepCopy: (obj) => JSON.parse(JSON.stringify(obj))
};

const State = {
    cells: [], size: 10, players: 2, aggro: false,
    activePlayer: 1, turn: 1, phase: 'setup', 
    selected: null, mode: null,
    setupMeta: {}, passCounter: {}, activePlayersList: [],
    history: [], MAX_PASS: 3, showHints: true,

    init(s, p, a) {
        this.size = s; this.players = p; this.aggro = a;
        this.cells = Array(s*s).fill(null).map(() => ({ type: 0, player: 0, uid: null }));
        this.activePlayersList = Array.from({length: p}, (_,i)=>i+1);
        this.turn = 1; this.activePlayer = 1; this.phase = 'setup';
        this.selected = null; this.mode = null;
        this.history = []; this.showHints = true;
        
        this.activePlayersList.forEach(pid => {
            this.setupMeta[pid] = { T:0, V:0 };
            this.passCounter[pid] = 0;
        });

        const fill = (pid, r0, c0) => {
            for(let r=0; r<4; r++) for(let c=0; c<3; c++) {
                this.cells[Utils.idx(r0+r, c0+c, s)] = { type:'P', player:pid, uid: Utils.getUid() };
            }
        };

        fill(1, 0, 0);
        if (p === 2) fill(2, s-4, s-3);
        else {
            fill(2, 0, s-3);
            if (p >= 3) fill(3, s-4, s-3);
            if (p >= 4) fill(4, s-4, 0);
        }
    },
    getCell(i) { return this.cells[i] || {type:0}; },
    count(pid, type) { return this.cells.filter(c => c.player === pid && c.type === type).length; },
    
    pushHistory() {
        if (this.phase !== 'game') return;
        const snapshot = {
            cells: Utils.deepCopy(this.cells),
            activePlayer: this.activePlayer,
            turn: this.turn,
            passCounter: Utils.deepCopy(this.passCounter),
            activePlayersList: Utils.deepCopy(this.activePlayersList)
        };
        this.history.push(snapshot);
        if (this.history.length > 10) this.history.shift();
    },
    
    popHistory() {
        if (this.history.length === 0) return false;
        const prev = this.history.pop();
        this.cells = prev.cells;
        this.activePlayer = prev.activePlayer;
        this.turn = prev.turn;
        this.passCounter = prev.passCounter;
        this.activePlayersList = prev.activePlayersList;
        this.selected = null; this.mode = null;
        return true;
    }
};

const Logic = {
    getNeighbors(idx) {
        const {r, c} = Utils.coords(idx, State.size);
        const offsets = [[-1,0],[1,0],[0,-1],[0,1],[-1,-1],[-1,1],[1,-1],[1,1]];
        return offsets.map(([dr, dc]) => Utils.idx(r+dr, c+dc, State.size)).filter(i => i !== -1);
    },

    getChainJumps(startIdx, currentIdx, visited = new Set()) {
        let jumps = [];
        const {r, c} = Utils.coords(currentIdx, State.size);
        const dirs = [[-2,0],[2,0],[0,-2],[0,2],[-2,-2],[-2,2],[2,-2],[2,2]];
        dirs.forEach(([dr, dc]) => {
            let destIdx = Utils.idx(r+dr, c+dc, State.size);
            let midIdx = Utils.idx(r+dr/2, c+dc/2, State.size);
            if (destIdx !== -1 && !visited.has(destIdx)) {
                const dest = State.getCell(destIdx);
                const mid = State.getCell(midIdx);
                if (mid.type !== 0 && dest.type === 0) {
                    if (State.aggro || mid.player === State.getCell(startIdx).player) {
                        jumps.push({ idx: destIdx, type: 'move' });
                        let newVisited = new Set(visited); newVisited.add(destIdx);
                        jumps.push(...this.getChainJumps(startIdx, destIdx, newVisited));
                    }
                }
            }
        });
        const unique = []; const seen = new Set();
        for (const j of jumps) { if (!seen.has(j.idx)) { unique.push(j); seen.add(j.idx); } }
        return unique;
    },

    getValidMoves(idx) {
        const p = State.getCell(idx);
        if (!p.type) return [];
        const {r, c} = Utils.coords(idx, State.size);
        let moves = [];

        if (p.type === 'P') {
            for(let dr=-1; dr<=1; dr++) for(let dc=-1; dc<=1; dc++) {
                if(!dr && !dc) continue;
                let tIdx = Utils.idx(r+dr, c+dc, State.size);
                if (tIdx === -1) continue;
                let t = State.getCell(tIdx);
                if (t.type === 0) moves.push({ idx: tIdx, type: 'move' });
                else if (t.player !== p.player) {
                    if (t.type === 'P') moves.push({ idx: tIdx, type: 'attack' });
                    if (t.type === 'V') {
                        let neighbors = Logic.getNeighbors(tIdx);
                        let hasOfficerSupport = neighbors.some(n => n!==idx && State.getCell(n).player === p.player && State.getCell(n).type === 'V');
                        if (hasOfficerSupport) moves.push({ idx: tIdx, type: 'attack' });
                    }
                }
                else if (t.player === p.player && t.type === 'P') {
                    if (State.count(p.player, 'V') === 0) moves.push({ idx: tIdx, type: 'special-promote' });
                }
            }
            moves.push(...this.getChainJumps(idx, idx));
        }
        else if (p.type === 'V') {
            [[0,1],[0,-1],[1,0],[-1,0]].forEach(([dr,dc]) => {
                for(let k=1; k<=2; k++) {
                    let tIdx = Utils.idx(r+dr*k, c+dc*k, State.size);
                    if (tIdx === -1) break;
                    let t = State.getCell(tIdx);
                    if (t.type === 0) moves.push({ idx: tIdx, type: 'move' });
                    else if (t.player !== p.player) { moves.push({ idx: tIdx, type: 'attack' }); break; } 
                    else break; 
                }
            });
            if (State.count(p.player, 'T') < 2) {
                Logic.getNeighbors(idx).forEach(nIdx => {
                    let t = State.getCell(nIdx);
                    if(t.player === p.player && t.type === 'V') moves.push({ idx: nIdx, type: 'special-tower' });
                });
            }
        }
        return moves;
    },

    checkEncirclement(idx) {
        let events = [];
        let me = State.getCell(idx);
        Logic.getNeighbors(idx).forEach(nIdx => {
            let victim = State.getCell(nIdx);
            if (victim.type === 'V' && victim.player !== me.player && victim.player !== 0) {
                let attackers = Logic.getNeighbors(nIdx).filter(n => State.getCell(n).player === me.player);
                if (attackers.length >= 2) {
                    let partner = attackers.find(a => a !== idx && State.getCell(a).type === 'P');
                    let action = 'kill'; let sac = null;
                    if (me.type === 'P' && partner !== undefined) { action = 'merge'; sac = partner; }
                    events.push({ victim: nIdx, action, sac, killer: idx });
                }
            }
        });
        return events;
    },

    isSetupZone(idx, pid) {
        const {r, c} = Utils.coords(idx, State.size);
        const s = State.size;
        if (pid === 1) return r <= 3 && c <= 2;
        if (State.players === 2) {
             if (pid === 2) return r >= s-4 && c >= s-3;
        } else {
             if (pid === 2) return r <= 3 && c >= s-3;
             if (pid === 3) return r >= s-4 && c >= s-3;
             if (pid === 4) return r >= s-4 && c <= 2;
        }
        return false;
    }
};

const View = {
    notify(msg, type='neutral') {
        const box = document.getElementById('notifications');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`; toast.innerText = msg;
        box.appendChild(toast);
        setTimeout(() => { toast.style.animation = 'toast-out 0.3s ease-in forwards'; setTimeout(() => toast.remove(), 300); }, 3000);
    },

    renderGrid() {
        const b = document.getElementById('board');
        b.style.gridTemplateColumns = `repeat(${State.size}, 1fr)`;
        b.innerHTML = '';
        for(let i=0; i<State.size**2; i++) {
            let div = document.createElement('div');
            let {r,c} = Utils.coords(i, State.size);
            div.className = `cell ${(r+c)%2 ? 'c1':'c2'}`;
            div.onclick = () => Controller.handle(i);
            b.appendChild(div);
        }
    },
    
    renderPieces() {
        const cells = document.getElementById('board').children;
        document.querySelectorAll('.indicator').forEach(e => e.remove());
        
        if (State.phase === 'setup') {
            for(let i=0; i<State.cells.length; i++) {
                if (Logic.isSetupZone(i, State.activePlayer)) cells[i].classList.add('setup-valid');
                else cells[i].classList.remove('setup-valid');
            }
        } else {
            for(let i=0; i<cells.length; i++) cells[i].classList.remove('setup-valid');
        }
        
        State.cells.forEach((p, i) => {
            const cell = cells[i];
            let el = cell.querySelector('.piece');
            if (p.type === 0) { if (el && !el.classList.contains('ghost')) el.remove(); return; }
            if (!el || el.dataset.uid !== p.uid) {
                if(el && !el.classList.contains('ghost')) el.remove();
                el = document.createElement('div'); el.dataset.uid = p.uid; cell.appendChild(el);
            }
            el.className = `piece p${p.player} type-${p.type}`;
            if (State.phase === 'game' && p.player === State.activePlayer) el.classList.add('active-glow');
        });

        if (State.selected !== null && State.phase === 'game' && State.mode !== 'dismantle') {
            let moves = Logic.getValidMoves(State.selected);
            cells[State.selected].classList.add('selected');
            moves.forEach(m => {
                let ind = document.createElement('div');
                let typeClass = 'ind-move';
                if (m.type === 'attack') typeClass = 'ind-attack';
                else if (m.type.startsWith('special')) typeClass = 'ind-special';
                if (typeClass !== 'ind-move' || State.showHints) {
                    ind.className = `indicator ${typeClass}`;
                    cells[m.idx].appendChild(ind);
                }
            });
        } else { Array.from(cells).forEach(c => c.classList.remove('selected')); }

        if (State.phase === 'setup' && State.selected !== null) cells[State.selected].classList.add('selected');
        if (State.mode === 'dismantle' && State.selected !== null) cells[State.selected].classList.add('selected');
        this.updateHUD();
    },

    spawnGhost(idx, type, player) {
        const cell = document.getElementById('board').children[idx];
        if(!cell) return;
        let g = document.createElement('div'); g.className = `piece p${player} type-${type} ghost`;
        cell.appendChild(g); setTimeout(() => g.remove(), 750);
    },

    updateHUD() {
        document.getElementById('badge').className = `badge p${State.activePlayer}`;
        document.getElementById('badge').innerText = `Игрок ${State.activePlayer}`;
        document.getElementById('turn-cnt').innerText = State.turn;
        document.getElementById('phase-msg').innerText = State.phase === 'setup' ? "ПОДГОТОВКА" : "БОЙ";
        const c = document.getElementById('controls'); c.innerHTML = '';

        if (State.phase === 'setup') {
            let m = State.setupMeta[State.activePlayer];
            let btnT = document.createElement('button'); btnT.innerText = `БАШНЯ (${1-m.T})`; 
            btnT.disabled = m.T >= 1 || State.selected === null; btnT.onclick = () => Controller.doSetup('T');
            let btnV = document.createElement('button'); btnV.innerText = `Офицер (${1-m.V})`;
            btnV.disabled = m.V >= 1 || State.selected === null; btnV.onclick = () => Controller.doSetup('V');
            let btnOk = document.createElement('button'); btnOk.className = 'btn-green'; btnOk.innerText = "ГОТОВО";
            btnOk.disabled = (m.T < 1 || m.V < 1); btnOk.onclick = () => Controller.endSetup();
            c.append(btnT, btnV, btnOk);
        } else {
            let btnPass = document.createElement('button');
            let passes = State.passCounter[State.activePlayer];
            let passLeft = State.MAX_PASS - passes;
            btnPass.className = passes > 0 ? 'btn-red' : 'btn-purple';
            btnPass.innerText = passes >= 2 ? `СДАТЬСЯ (${passLeft})` : `ПАС (${passes}/${State.MAX_PASS})`;
            btnPass.onclick = () => Actions.pass();
            
            let btnDis = document.createElement('button'); btnDis.innerText = "ПОНИЗИТЬ";
            let p = State.getCell(State.selected || -1);
            btnDis.disabled = !(p.type === 'V' && p.player === State.activePlayer);
            btnDis.onclick = () => { State.mode='dismantle'; View.notify('Кликните пустую клетку рядом'); };
            
            let btnUndo = document.createElement('button');
            btnUndo.className = 'btn-blue btn-icon-only'; btnUndo.title = "Отменить ход";
            btnUndo.innerHTML = '<span class="material-icons">undo</span>';
            btnUndo.disabled = State.history.length === 0;
            btnUndo.onclick = () => Actions.undo();

            let btnEye = document.createElement('button');
            btnEye.className = 'btn-icon-only'; btnEye.style.background = State.showHints ? '#27ae60' : 'rgba(128,128,128,0.2)';
            btnEye.title = "Подсказки";
            btnEye.innerHTML = `<span class="material-icons">${State.showHints ? 'visibility' : 'visibility_off'}</span>`;
            btnEye.onclick = () => { State.showHints = !State.showHints; View.renderPieces(); };
            
            // Only add Eye button here (others moved to left panel)
            c.append(btnPass, btnDis, btnUndo, btnEye);
        }
    }
};

const Controller = {
    locked: false,
    handle(i) {
        if (this.locked) return;
        if (State.phase === 'setup') {
            let p = State.getCell(i);
            if (p.player === State.activePlayer && p.type === 'P') { State.selected = i; View.renderPieces(); }
            return;
        }

        if (State.mode === 'dismantle') {
            if (Logic.getNeighbors(State.selected).includes(i) && State.getCell(i).type === 0) {
                Actions.dismantle(State.selected, i);
            } else { State.mode = null; View.notify("Понижение отменено"); View.renderPieces(); }
            return;
        }
        if (State.mode === 'sacrifice') {
            if (Logic.getNeighbors(State.selected).includes(i)) {
                let t = State.getCell(i);
                if (t.player === State.activePlayer && t.type !== 0) Actions.moveTower(State.selected, i);
            }
            State.mode = null; State.selected = null; View.renderPieces();
            return;
        }

        let cell = State.getCell(i);
        if (State.selected !== null) {
            let moves = Logic.getValidMoves(State.selected);
            let move = moves.find(m => m.idx === i);
            if (move) { Actions.execute(State.selected, i, move.type); return; }
        }

        if (cell.player === State.activePlayer) {
            State.selected = i; State.mode = null;
            if (cell.type === 'T') { State.mode = 'sacrifice'; View.notify("Выберите жертву рядом"); }
            View.renderPieces();
        } else { State.selected = null; View.renderPieces(); }
    },

    doSetup(type) {
        let p = State.getCell(State.selected);
        if(type==='T') State.setupMeta[State.activePlayer].T++; else State.setupMeta[State.activePlayer].V++;
        p.type = type; State.selected = null; View.renderPieces();
    },

    endSetup() {
        let idx = State.activePlayersList.indexOf(State.activePlayer);
        let next = State.activePlayersList[(idx + 1) % State.activePlayersList.length];
        if (next < State.activePlayer) { State.phase = 'game'; State.activePlayer = 1; State.turn = 1; } else { State.activePlayer = next; }
        State.selected = null; View.renderPieces();
    }
};

const Actions = {
    async execute(from, to, type) {
        Controller.locked = true; State.pushHistory();
        const me = State.getCell(from); const target = State.getCell(to);

        if (type === 'attack') { View.spawnGhost(to, target.type, target.player); AudioEngine.play('attack'); }
        else if (type.startsWith('special')) { View.spawnGhost(to, target.type, target.player); View.spawnGhost(from, me.type, me.player); AudioEngine.play('special'); }
        else AudioEngine.play('move');

        if (type === 'special-promote') {
            State.cells[to] = { type:'V', player: me.player, uid: me.uid }; 
            State.cells[from] = { type:0, player:0, uid:null };
            View.notify("Слияние: Рядовой повышен!");
        } else if (type === 'special-tower') {
             State.cells[to] = { type:'T', player: me.player, uid: me.uid }; 
             State.cells[from] = { type:0, player:0, uid:null };
             View.notify("Слияние: Новая Башня!");
        } else {
            if (target.type === 'T') { View.notify(`БАШНЯ ИГРОКА ${target.player} ПАЛА!`, 'good'); AudioEngine.play('special'); }
            State.cells[to] = { ...me }; State.cells[from] = { type:0, player:0, uid:null };
        }
        
        State.passCounter[State.activePlayer] = 0; View.renderPieces();

        if (!type.startsWith('special') && me.type === 'P') {
            let events = Logic.checkEncirclement(to);
            if (events.length > 0) {
                await Utils.wait(300);
                events.forEach(ev => {
                    let v = State.getCell(ev.victim); View.spawnGhost(ev.victim, v.type, v.player);
                    State.cells[ev.victim] = { type:0, player:0, uid:null }; AudioEngine.play('attack');
                    if (ev.action === 'merge') {
                        let sac = State.getCell(ev.sac); View.spawnGhost(ev.sac, sac.type, sac.player);
                        State.cells[ev.sac] = { type:0, player:0, uid:null };
                        State.getCell(ev.killer).type = 'V'; View.notify("КЛЕЩИ! Слияние!", 'good');
                    } else { View.notify("КЛЕЩИ! Враг уничтожен!", 'good'); }
                });
                View.renderPieces();
            }
        }
        Controller.locked = false; this.nextTurn();
    },

    async moveTower(from, to) {
        State.pushHistory();
        let t = State.getCell(from); let sac = State.getCell(to);
        View.spawnGhost(to, sac.type, sac.player);
        State.cells[to] = { ...t }; State.cells[from] = { type:0, player:0, uid:null };
        State.passCounter[State.activePlayer] = 0;
        View.renderPieces(); this.nextTurn();
    },

    dismantle(from, to) {
        State.pushHistory();
        let v = State.getCell(from); View.spawnGhost(from, 'V', v.player);
        State.cells[from] = { type: 'P', player: v.player, uid: Utils.getUid() };
        State.cells[to] = { type:'P', player: v.player, uid: Utils.getUid() };
        State.mode = null; State.passCounter[State.activePlayer] = 0; AudioEngine.play('special');
        View.notify("Понижение успешно"); View.renderPieces(); this.nextTurn();
    },

    undo() { if (State.popHistory()) { View.notify("Ход отменен", "special"); View.renderPieces(); } },

    pass() {
        State.pushHistory(); State.passCounter[State.activePlayer]++;
        if (State.passCounter[State.activePlayer] >= State.MAX_PASS) this.eliminate(State.activePlayer, "Предел пасов");
        else this.nextTurn();
    },

    eliminate(pid, reason="Уничтожен") {
        View.notify(`Игрок ${pid} выбывает: ${reason}`, 'bad'); AudioEngine.play('attack');
        State.cells.forEach(c => { if(c.player === pid) { c.type=0; c.player=0; } });
        State.activePlayersList = State.activePlayersList.filter(p => p !== pid);
        View.renderPieces();
        if (State.activePlayersList.length === 1) {
            AudioEngine.play('win');
            setTimeout(() => { 
                document.getElementById('modal-win').style.display = 'flex';
                document.getElementById('win-title').innerText = `ПОБЕДА!`;
                document.getElementById('win-desc').innerText = `Игрок ${State.activePlayersList[0]} завоевал поле боя`;
            }, 600);
        } else { this.nextTurn(); }
    },

    nextTurn() {
        let losers = [];
        State.activePlayersList.forEach(pid => {
            if (!State.cells.some(c => c.player === pid && c.type === 'T')) losers.push(pid);
        });
        if (losers.length > 0) { losers.forEach(id => this.eliminate(id, "Потеря базы")); return; }
        let currIdx = State.activePlayersList.indexOf(State.activePlayer);
        State.activePlayer = State.activePlayersList[(currIdx+1) % State.activePlayersList.length];
        if (currIdx === State.activePlayersList.length - 1) State.turn++;
        State.selected = null; State.mode = null; View.renderPieces();
    }
};

const Game = {
    isLightMode: false,
    
    start() {
        const s = parseInt(document.getElementById('s-size').value);
        const p = parseInt(document.getElementById('s-players').value);
        const a = document.getElementById('s-aggro').checked;
        
        AudioEngine.init();
        AudioEngine.noiseBuffer = AudioEngine.createNoiseBuffer(); 

        document.getElementById('modal').style.display = 'none';
        document.getElementById('game-layout').style.display = 'grid';
        State.init(s, p, a); View.renderGrid(); View.renderPieces();
    },
    
    toggleTheme() {
        document.body.classList.toggle('theme-future');
    },
    
    toggleMode() {
        this.isLightMode = !this.isLightMode;
        if(this.isLightMode) document.body.classList.add('mode-light');
        else document.body.classList.remove('mode-light');
    },

    toggleAudio() {
        AudioEngine.muted = !AudioEngine.muted;
        document.getElementById('icon-sound').innerText = AudioEngine.muted ? 'volume_off' : 'volume_up';
        if(!AudioEngine.muted) AudioEngine.play('move'); // Test sound
    }
};
</script>
</body>
</html>